// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to  DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// 
// 

#region

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Threading;
using WinterLeaf.Classes;
using WinterLeaf.Containers;
using WinterLeaf.Enums;
using WinterLeaf.tsObjects;

#endregion

namespace DNT_FPS_Demo_Game_Dll.Tools
{
    public partial class Main : TorqueScriptTemplate
    {
        [Torque_Decorations.TorqueCallBack("", "EditorChooseLevelGui", "onWake", "", 1, 2500, false)]
        public void EditorChooseLevelGuiOnWake(coGuiContainer thisObj)
        {
            // first check if we have a level file to load, then we'll bypass this
            if (!sGlobal["levelToLoad"].Equals(""))
            {
                // First try using the file path raw... it may already be good.
                string file = Util.findFirstFile(sGlobal["levelToLoad"], false);
                if (file.Equals(""))
                {
                    string levelFile = "levels/";
                    string ext = sGlobal["levelToLoad"].Substring(sGlobal["levelToLoad"].Length - 3);
                    if (!ext.Equals("mis"))
                        levelFile += sGlobal["levelToLoad"] + ".mis";
                    else
                        levelFile += sGlobal["levelToLoad"];

                    // lets make sure the file exists
                    file = Util.findFirstFile(levelFile, false);
                }

                // Clear out the $levelToLoad so we don't attempt to load the level again
                // later on.
                sGlobal["levelToLoad"] = "";

                if (!file.Equals(""))
                {
                    console.Call("WE_EditLevel", new string[] { file });
                    return;
                }
            }

            //If no valid name, then push the level chooser
            ((coGuiCanvas)console.GetObjectID("Canvas")).pushDialog("EditorChooseLevelContainer");
        }

        [Torque_Decorations.TorqueCallBack("", "EditorChooseLevelContainer", "onWake", "", 1, 2500, false)]
        public void EditorChooseLevelContainerOnWake(coGuiContainer thisObj)
        {
            // Build the test lists
            coGuiMLTextCtrl WE_LevelList = console.GetObjectID("WE_LevelList");
            coGuiMLTextCtrl WE_TemplateList = console.GetObjectID("WE_TemplateList");

            string leveltext = "<linkcolor:0000FF><linkcolorhl:FF0000>";
            string templatetext = "<linkcolor:0000FF><linkcolorhl:FF0000>";
            for (string file = Util.findFirstFile(sGlobal["$Server::MissionFileSpec"], false); !file.Equals(""); file = Util.findNextFile(sGlobal["$Server::MissionFileSpec"]))
            {
                string name = getLevelDisplayName(file);
                string n = Util.strlwr(name);
                if(Util.strstr(n, "template") == -1)
                    leveltext += "<a:gamelink:" + file + ">" + name + "</a><br>";
                else
                    templatetext += "<a:gamelink:" + file + ">" + name + "</a><br>";
            }

            WE_LevelList.setText(leveltext);
            WE_LevelList.forceReflow();
            WE_LevelList.scrollToTop(0,0);

            WE_TemplateList.setText(templatetext);
            WE_TemplateList.forceReflow();
            WE_TemplateList.scrollToTop(0,0);
        }

        public void WE_EditLevel(string levelFile)
        {
            console.Call("EditorOpenMission", new string[] { levelFile });
        }

        public void WE_ReturnToMainMenu()
        {
            console.Call("loadMainMenu");
        }

        [Torque_Decorations.TorqueCallBack("", "WE_TemplateList", "onURL", "", 1, 2500, false)]
        public void WE_TemplateListOnURL(coGuiMLTextCtrl thisObj, string url)
        {
            // Remove 'gamelink:' from front
            string levelFile = url.Substring(9, 1024);
            WE_EditLevel(levelFile);
        }

        [Torque_Decorations.TorqueCallBack("", "WE_LevelList", "onURL", "", 1, 2500, false)]
        public void WE_LevelListOnURL(coGuiMLTextCtrl thisObj, string url)
        {
            // Remove 'gamelink:' from front
            string levelFile = url.Substring(9, 1024);
            WE_EditLevel(levelFile);
            ((coGuiContainer)console.GetObjectID("EditorGui"))["saveAs"] = true.AsString();
        }

        public string getLevelDisplayName(string levelFile)
        {
            coFileObject file = new Torque_Class_Helper("FileObject").Create();
            coScriptObject MissionInfoObject = "";
            if (file.openForRead(levelFile))
            {
                bool inInfoBlock = false;

                while (!file.isEOF())
                {
                    string line = file.readLine();
                    line = line.Trim();

                    if (line.Equals("new ScriptObject(MissionInfo) {") || line.Equals("new LevelInfo(theLevelInfo) {"))
                        inInfoBlock = true;
                    else if(inInfoBlock && line.Equals("};"))
                    {
                        inInfoBlock = false;
                        MissionInfoObject += line;
                        break;
                    }

                    if(inInfoBlock)
                        MissionInfoObject += line + " ";
                }
                file.close();
            }
            MissionInfoObject = console.Eval(MissionInfoObject, true);
            file.delete();
            string name;
            if (!MissionInfoObject["levelName"].Equals(""))
                name = MissionInfoObject["levelName"];
            else
                name = Util.fileBase(levelFile);

            MissionInfoObject.delete();
            return name;
        }
    }
}
